== Breaking down designs into tasks

You've made it through the first round of refinement for the project! In this next round, you can assume that Product has answered all of your team's questions and you have updated designs. Now you'll be working with Product to carve features out of this info. This is when you'll first come to the Jira board.

[[fig-1.3-1]]
.Example of Jira Board
image::images/fig-1.3-1.png["example of a backlog in Jira"]

The tickets you make here are going to go through refinement once you start bringing in more developers and other teams. The goal at this stage is to make action items for segments of the designs. The user info screen for example has several pieces that can be broken out into features. The featured section and the table are inndividual features. You're trying to get people thinking about how the designs will actually work and start bringing in that technical perspective. As a senior full-stack dev, you might try to group features based on data relationships.

This will help make it easier for back-end changes to be made and deployed as the front-end is being built. This is also the point where you can still call out any big issues you run into as you start thinking through the tech stack. Any time you have a thought for a feature or technical requirements, make sure a ticket gets made. If there isn't a ticket, the work won't get prioritized.

=== Refining tasks from feature requirements

You're at the point in the project where Product should have some user stories written for you to refine with technical details. This doesn't happen all the time. Many times you'll be working with Product to fully define features, but they'll have some details to get started with from the previous round.

You can assume that your team follows a normal agile process with two week sprints and the standard meetings like daily standup, backlog grooming, sprint planning, and retro. At this point, you'll go to a backlog grooming meeting and start going through the tickets in the Jira backlog. This meeting should include the development team, QA team, and Product team so that everyone can ask questions and bring up concerns. Feature tickets should be broken down into the smallest piece of work a developer can do. In order to keep expectations aligned with what the team can output, estimates are usually made on every ticket for how complex the task is.

When you're going through tickets during backlog grooming, don't hesitate to slow things down. If you spend the entire time on one ticket, then that shows Product where they need to improve and it can be brought up in the retro meeting. Make sure every ticket has acceptance criteria that's agreed on by Product, QA, and your team. If the ticket has UI elements, make sure you have access to the designs for both desktop and mobile. Every ticket should also have background information on how the functionality fits in the overall app so developers have context. All of the developers should be in agreement on estimates for each ticket.

This might seem like a lot of fuss over tickets, but doing all of this upfront saves your team time. Getting everyone on the same page in the very beginning helps keep your team unblocked. With this level of documentation in each ticket, there shouldn't be ambiguity in the task when anyone on the project gets to it. Here's an example of info you will find in a well-defined ticket.

----
Title: [Back-end, QA] Create endpoint for table data on user info screen
Description: As a user, I need to see a table with my purchase info. This info should include the product name, price, estimated arrival date, and quantity in each row on the table. This table should also be sortable by clicking on the column headers. It should have pagination so users can go through their purchase history for the previous 12 months. It should match the designs attached. (See fig 1.1-2 and fig 1.1-4)
Acceptance criteria: 
    - Update data schema to include purchase history definition: product name, price, estimated arrival date, quantity
    - Run migration on database
    - Create endpoint that responds with user purchase history for past 12 months
    - Ensure authentication is working correctly
    - Implement validation on request data
    - Write tests for new endpoint
    - Write docs for how the endpoint works so front-end can use it
Points: 5
----

It should be very clear to any engineer what needs to be done, although it shouldn't tell them how to implement it. That's something they can decide after the team's discussed it. Having tickets written out like this will spark deeper technical discussions that will help drive the overall architecture of your project. This is when you start to take the tasks from Product and refine them even more as a development team. It's always a good idea to include any highlights that come out of team meetings in the tickets so everyone remembers why things were done that way.

It might seem like this is a long process, but usually you can define the tickets in the upcoming sprint in a few days. Then once the sprint starts you can jump in. But before you get pick your own tickets and start coding, there are a few more conversations you'll need to have.